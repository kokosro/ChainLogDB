//
//  DBLogDatabase.swift
//  ChainLogDb
//
//  Actor-based SQLite wrapper for thread-safe database operations
//  Executes SQL generated by DBLogProcessor
//

import Foundation
import SQLite3

// MARK: - DBLog Database Actor

/// Thread-safe SQLite database wrapper using Swift actor
public actor DBLogDatabase {
    
    // MARK: - Properties
    
    private var db: OpaquePointer?
    private let dbPath: String
    private var isOpen = false
    
    // MARK: - Initialization
    
    /// Initialize with a database file path
    /// - Parameter path: Path to SQLite database file. Use `:memory:` for in-memory database.
    public init(path: String) {
        self.dbPath = path
    }
    
    /// Initialize with default path in app's documents directory
    public init() {
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
        self.dbPath = documentsPath.appendingPathComponent("dblog.sqlite").path
    }
    
    // Note: Call close() explicitly before releasing the database.
    // SQLite handles cleanup of unclosed connections, but explicit closure is preferred.
    
    // MARK: - Connection Management
    
    /// Open the database connection
    public func open() throws {
        guard !isOpen else { return }
        
        // Ensure parent directory exists
        let parentDir = (dbPath as NSString).deletingLastPathComponent
        if !FileManager.default.fileExists(atPath: parentDir) {
            try FileManager.default.createDirectory(atPath: parentDir, withIntermediateDirectories: true)
        }
        
        var dbPointer: OpaquePointer?
        let result = sqlite3_open(dbPath, &dbPointer)
        
        guard result == SQLITE_OK, let database = dbPointer else {
            let error = String(cString: sqlite3_errmsg(dbPointer))
            sqlite3_close(dbPointer)
            throw DBLogError.sqlExecutionFailed("Failed to open database: \(error)")
        }
        
        self.db = database
        self.isOpen = true
        
        // Enable WAL mode for better concurrent access
        try execute("PRAGMA journal_mode = WAL")
        
        // Set busy timeout to 5 seconds to handle concurrent access
        try execute("PRAGMA busy_timeout = 5000")
        
        // Enable foreign keys
        try execute("PRAGMA foreign_keys = ON")
        
        // Initialize metadata tables
        try execute(DBLogProcessor.createMetadataTableSQL)
        try execute(DBLogProcessor.createSchemaVersionsTableSQL)
    }
    
    /// Close the database connection
    public func close() {
        guard isOpen, let db = db else { return }
        sqlite3_close(db)
        self.db = nil
        self.isOpen = false
    }
    
    /// Get the database file path
    public func getPath() -> String {
        dbPath
    }
    
    // MARK: - SQL Execution
    
    /// Execute a SQL statement that doesn't return results
    public func execute(_ sql: String) throws {
        guard isOpen, let db = db else {
            throw DBLogError.sqlExecutionFailed("Database not open")
        }
        
        var errorMessage: UnsafeMutablePointer<CChar>?
        let result = sqlite3_exec(db, sql, nil, nil, &errorMessage)
        
        if result != SQLITE_OK {
            let error = errorMessage.map { String(cString: $0) } ?? "Unknown error"
            sqlite3_free(errorMessage)
            throw DBLogError.sqlExecutionFailed("\(error) - SQL: \(sql)")
        }
    }
    
    /// Execute multiple SQL statements in a transaction
    public func executeInTransaction(_ statements: [String]) throws {
        try execute("BEGIN TRANSACTION")
        
        do {
            for sql in statements {
                try execute(sql)
            }
            try execute("COMMIT")
        } catch {
            try? execute("ROLLBACK")
            throw error
        }
    }
    
    /// Execute a prepared statement with parameters
    public func execute(_ prepared: DBLogPreparedStatement) throws {
        guard isOpen, let db = db else {
            throw DBLogError.sqlExecutionFailed("Database not open")
        }
        
        var stmt: OpaquePointer?
        
        guard sqlite3_prepare_v2(db, prepared.sql, -1, &stmt, nil) == SQLITE_OK else {
            let error = String(cString: sqlite3_errmsg(db))
            throw DBLogError.sqlExecutionFailed("Prepare failed: \(error)")
        }
        
        defer { sqlite3_finalize(stmt) }
        
        // Bind parameters
        for (index, value) in prepared.parameters.enumerated() {
            let paramIndex = Int32(index + 1) // SQLite parameters are 1-indexed
            try bindValue(value, to: stmt, at: paramIndex)
        }
        
        // Execute
        let result = sqlite3_step(stmt)
        if result != SQLITE_DONE && result != SQLITE_ROW {
            let error = String(cString: sqlite3_errmsg(db))
            throw DBLogError.sqlExecutionFailed("Execution failed: \(error)")
        }
    }
    
    // MARK: - Query Execution
    
    /// Query and return results as array of dictionaries
    public func query(_ sql: String) throws -> [[String: Any]] {
        guard isOpen, let db = db else {
            throw DBLogError.sqlExecutionFailed("Database not open")
        }
        
        var stmt: OpaquePointer?
        
        guard sqlite3_prepare_v2(db, sql, -1, &stmt, nil) == SQLITE_OK else {
            let error = String(cString: sqlite3_errmsg(db))
            throw DBLogError.sqlExecutionFailed("Prepare failed: \(error) - SQL: \(sql)")
        }
        
        defer { sqlite3_finalize(stmt) }
        
        var results: [[String: Any]] = []
        let columnCount = sqlite3_column_count(stmt)
        
        while sqlite3_step(stmt) == SQLITE_ROW {
            var row: [String: Any] = [:]
            
            for i in 0..<columnCount {
                let columnName = String(cString: sqlite3_column_name(stmt, i))
                row[columnName] = extractValue(from: stmt, column: i)
            }
            
            results.append(row)
        }
        
        return results
    }
    
    /// Query a single row by id
    public func queryRow(table: String, id: String) throws -> [String: Any]? {
        let sql = DBLogProcessor.selectById(from: table, id: id)
        let results = try query(sql)
        return results.first
    }
    
    /// Query all rows from a table
    public func queryAll(table: String) throws -> [[String: Any]] {
        let sql = DBLogProcessor.selectAll(from: table)
        return try query(sql)
    }
    
    /// Query all rows with a WHERE condition
    public func queryWhere(table: String, condition: String) throws -> [[String: Any]] {
        let sql = DBLogProcessor.selectAll(from: table, where: condition)
        return try query(sql)
    }
    
    /// Query count of rows in a table
    public func queryCount(table: String) throws -> Int {
        let sql = DBLogProcessor.selectCount(from: table)
        let results = try query(sql)
        return (results.first?["count"] as? Int) ?? 0
    }
    
    // MARK: - Schema Introspection
    
    /// Check if a table exists
    public func tableExists(_ name: String) throws -> Bool {
        let sql = DBLogProcessor.tableExistsQuery(name)
        let results = try query(sql)
        return !results.isEmpty
    }
    
    /// Get column information for a table
    public func tableColumns(_ name: String) throws -> [TableColumn] {
        let sql = DBLogProcessor.tableSchemaQuery(name)
        let results = try query(sql)
        
        return results.compactMap { row in
            guard let columnName = row["name"] as? String,
                  let columnType = row["type"] as? String else {
                return nil
            }
            
            return TableColumn(
                name: columnName,
                type: columnType,
                notNull: (row["notnull"] as? Int) == 1,
                primaryKey: (row["pk"] as? Int) == 1,
                defaultValue: row["dflt_value"] as? String
            )
        }
    }
    
    /// Get the schema version for a table
    public func schemaVersion(for table: String) throws -> Int {
        let sql = DBLogProcessor.getSchemaVersion(for: table)
        let results = try query(sql)
        
        if let row = results.first, let version = row["version"] as? Int {
            return version
        }
        return 0
    }
    
    /// Update the schema version for a table
    public func setSchemaVersion(for table: String, version: Int) throws {
        let sql = DBLogProcessor.updateSchemaVersion(for: table, version: version)
        try execute(sql)
    }
    
    // MARK: - Metadata
    
    /// Get a metadata value by key
    public func getMetadata(key: String) throws -> String? {
        let sql = "SELECT value FROM \"_dblog_meta\" WHERE key = \(key.sqlEscaped)"
        let results = try query(sql)
        return results.first?["value"] as? String
    }
    
    /// Set a metadata value
    public func setMetadata(key: String, value: String) throws {
        let sql = "INSERT OR REPLACE INTO \"_dblog_meta\" (key, value) VALUES (\(key.sqlEscaped), \(value.sqlEscaped))"
        try execute(sql)
    }
    
    /// Get the last processed chain log index
    public func getLastChainIndex() throws -> Int {
        if let value = try getMetadata(key: "last_chain_index"),
           let index = Int(value) {
            return index
        }
        return -1
    }
    
    /// Set the last processed chain log index
    public func setLastChainIndex(_ index: Int) throws {
        try setMetadata(key: "last_chain_index", value: String(index))
    }
    
    /// Get the last processed dblog index
    public func getLastDBLogIndex() throws -> Int {
        if let value = try getMetadata(key: "last_dblog_index"),
           let index = Int(value) {
            return index
        }
        return -1
    }
    
    /// Set the last processed dblog index
    public func setLastDBLogIndex(_ index: Int) throws {
        try setMetadata(key: "last_dblog_index", value: String(index))
    }
    
    // MARK: - DBLog Action Processing
    
    /// Process a single DBLog action
    public func process(_ action: DBLogAction) throws {
        // For migrations, check if already applied before executing
        if case .migrate(let migrateAction) = action {
            let currentVersion = try schemaVersion(for: migrateAction.table)
            if currentVersion >= migrateAction.migration.version {
                // Already migrated to this version or higher, skip
                return
            }
        }
        
        let statements = DBLogProcessor.sqlStatements(for: action)
        for sql in statements {
            do {
                try execute(sql)
            } catch let error as DBLogError {
                // Handle idempotent migration errors - if column already exists, treat as success
                // This can happen when replaying ChainLog after device data clear
                if case .sqlExecutionFailed(let message) = error,
                   sql.contains("ADD COLUMN"),
                   message.contains("duplicate column name") {
                    // Column already exists - this is fine, the desired state is achieved
                    print("[DBLogDatabase] Ignoring duplicate column error (idempotent migration): \(message)")
                    continue
                }
                throw error
            }
        }
        
        // Update schema version if this is a migration
        if case .migrate(let migrateAction) = action {
            try setSchemaVersion(for: migrateAction.table, version: migrateAction.migration.version)
        }
    }
    
    /// Process multiple DBLog actions in a transaction
    public func process(_ actions: [DBLogAction]) throws {
        try execute("BEGIN TRANSACTION")
        
        do {
            for action in actions {
                try process(action)
            }
            try execute("COMMIT")
        } catch {
            try? execute("ROLLBACK")
            throw error
        }
    }
    
    /// Process actions and update tracking indices
    public func processAndTrack(_ actions: [DBLogAction], chainIndex: Int) throws {
        try execute("BEGIN TRANSACTION")
        
        do {
            var lastDBLogIndex = -1
            
            for action in actions {
                try process(action)
                
                // Extract dblogindex from action
                let dblogindex: Int
                switch action {
                case .schema(let a): dblogindex = a.dblogindex
                case .set(let a): dblogindex = a.dblogindex
                case .delete(let a): dblogindex = a.dblogindex
                case .migrate(let a): dblogindex = a.dblogindex
                }
                
                if dblogindex > lastDBLogIndex {
                    lastDBLogIndex = dblogindex
                }
            }
            
            try setLastChainIndex(chainIndex)
            if lastDBLogIndex >= 0 {
                try setLastDBLogIndex(lastDBLogIndex)
            }
            
            try execute("COMMIT")
        } catch {
            try? execute("ROLLBACK")
            throw error
        }
    }
    
    // MARK: - Private Helpers
    
    /// Bind a DBLogValue to a prepared statement parameter
    private func bindValue(_ value: DBLogValue, to stmt: OpaquePointer?, at index: Int32) throws {
        guard let stmt = stmt else { return }
        
        let result: Int32
        
        switch value {
        case .null:
            result = sqlite3_bind_null(stmt, index)
        case .bool(let v):
            result = sqlite3_bind_int(stmt, index, v ? 1 : 0)
        case .int(let v):
            result = sqlite3_bind_int64(stmt, index, Int64(v))
        case .double(let v):
            result = sqlite3_bind_double(stmt, index, v)
        case .string(let v):
            result = sqlite3_bind_text(stmt, index, v, -1, unsafeBitCast(-1, to: sqlite3_destructor_type.self))
        case .array, .object:
            // Serialize complex types as JSON
            if let data = try? JSONEncoder().encode(value),
               let json = String(data: data, encoding: .utf8) {
                result = sqlite3_bind_text(stmt, index, json, -1, unsafeBitCast(-1, to: sqlite3_destructor_type.self))
            } else {
                result = sqlite3_bind_null(stmt, index)
            }
        }
        
        if result != SQLITE_OK {
            throw DBLogError.sqlExecutionFailed("Failed to bind parameter at index \(index)")
        }
    }
    
    /// Extract a value from a result row
    private func extractValue(from stmt: OpaquePointer?, column: Int32) -> Any? {
        guard let stmt = stmt else { return nil }
        
        let type = sqlite3_column_type(stmt, column)
        
        switch type {
        case SQLITE_NULL:
            return nil
        case SQLITE_INTEGER:
            return Int(sqlite3_column_int64(stmt, column))
        case SQLITE_FLOAT:
            return sqlite3_column_double(stmt, column)
        case SQLITE_TEXT:
            if let text = sqlite3_column_text(stmt, column) {
                return String(cString: text)
            }
            return nil
        case SQLITE_BLOB:
            if let blob = sqlite3_column_blob(stmt, column) {
                let size = sqlite3_column_bytes(stmt, column)
                return Data(bytes: blob, count: Int(size))
            }
            return nil
        default:
            return nil
        }
    }
}

// MARK: - Supporting Types

/// Information about a table column
public struct TableColumn: Sendable, Equatable {
    public let name: String
    public let type: String
    public let notNull: Bool
    public let primaryKey: Bool
    public let defaultValue: String?
    
    nonisolated public init(name: String, type: String, notNull: Bool, primaryKey: Bool, defaultValue: String?) {
        self.name = name
        self.type = type
        self.notNull = notNull
        self.primaryKey = primaryKey
        self.defaultValue = defaultValue
    }
}
